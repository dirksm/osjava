<?xml version="1.0"?>
<document>

  <properties>
      <author email="bayard@generationjava.com">Henri Yandell</author>
      <title>Introduction</title>
  </properties>

  <body>
    <section name="GenerationJava.com's Simple-JNDI">
<p>
Simple-JNDI is intended to solve two problems. The first is that of finding a container independent way of opening a database connection, the second is to find a good way of specifying application configurations.
</p>
<p>
In a J2EE container, you can use JNDI as a java.sql.Connection factory. This code however is not usable outside of a J2EE container as you cannot guarrentee you have a JNDI implementation available, and to be honest, you don't want to start some other server to make your simple script run. Simple-JNDI is not a server, it is merely an API, however it looks exactly the same as the JNDI client code used in a J2EE container.
</p>
<p>
Applications need configuration. A servlets container uses the web.xml files to configure, while a J2EE container uses a different system, for example, JBoss has a jboss.jcml configuration file which sets a system up via JMX managed beans. An application <i>could</i> however use Simple-JNDI for parameter values.
</p>
</section>
<section name="Using Simple-JNDI">
<p>
Using Simple-JNDI is the same as using JNDI itself. So this is not covered here, however the examples do give the basic gist.
</p>
</section>
<section name="Installing Simple-JNDI">
<p>
Installing Simple-JNDI is as simple as <a href="http://www.generationjava.com/docs/simple-jndi/dependencies.html">adding</a> the simple-jndi jar, genjava-core jar, jdbc 2.0 jar and the commons-lang jar to your classpath.
</p>
</section>
<section name="Setting up Simple-JNDI">
<p>
This is where all the work goes in a Simple-JNDI installation. Firstly you need a jndi.properties file, which somehow needs to go into your classpath. This jndi.properties needs one manadatory value:
</p>
<code>
java.naming.factory.initial=com.generationjava.jndi.PropertiesFactory
</code>
<p>
This property is a part of the jndi specification, java.naming.factory.initial. This should be set equal to com.generationjava.jndi.PropertiesFactory.
</p>
<p>
There are two optional, simple-jndi specific parameters. <br />
The first, com.generationjava.jndi.root, is the location of your simple-jndi root, which is the location in which simple-jndi looks for values when code asks for them. The following code block details a few examples with explanatory comments.
</p>
<code>
# absolute directory, using the default file protocol<br />
com.generationjava.jndi.root=/home/hen/gj/simple-jndi/config/<br />
<br />
# relative directory, using the default file protocol<br />
com.generationjava.jndi.root=config/<br />
<br />
# specified file protocol with an absolute directory<br />
com.generationjava.jndi.root=file:///home/hen/gj/simple-jndi/config/<br />
<br />
# specified file protocol with a relative directory<br />
com.generationjava.jndi.root=file://config/<br />
<br />
# classpath protocol with a package 'config'<br />
com.generationjava.jndi.root=classpath://config<br />
</code>
<p>
If no com.generationjava.jndi.root is specified, then a classpath root is chosen, with no package.
</p>
<p>
The second optional parameter is the delimiter used to separate elements in a lookup value. This allows code to get closer to pretending to be another JNDI implementation, such as DNS or LDAP.</p>
<code>
# DNS/Java like delimiters<br />
com.generationjava.jndi.delimiter=.<br />
<br />
# LDAP/XPath like delimiters<br />
com.generationjava.jndi.delimiter=/<br />
</code>
<p>
If no com.generationjava.jndi.delimiter is specified, then a '.' (dot) is chosen. 
</p>
</section>
</body>
</document>
